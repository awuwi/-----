处理哈希冲突的方式有两种：避免和解决，即冲突避免机制（Collision Avoidance）和冲突解决机制（Collision Resolution）。
A.哈希冲突解决策略：开放寻址法（Open Addressing）
B.哈希冲突解决策略：链接技术（chaining）
链接技术（chaining）： 
原理： 将采用额外的数据结构来处理冲突，其将哈希表中每个位置（slot）都映射到了一个链表。
当冲突发生时，冲突的元素将被添加到桶（bucket）列表中，而每个桶都包含了一个链表以存储相同哈希的元素。

开放寻址法：
原理：
下面介绍一个线性探查的例子：（本位置X被占据，继续寻找下一个x+1的位置，直到找到空槽为止）
example：设散列表的长度为11，哈希函数H（k）=(k的第一个字母在字母表中的序号)mod11, 
若输入的顺序为（D，BA，TN，M，CI，I，K，X，TA）采用内散列表，处理冲突方法为线性探查法，按要求构造哈希表，
在等概率的情况下，查找成功的平均查找长度为？

D： 4%11=4   1次

BA：2%11=2   1次

TN：20%11=9   1次

M：13%11=2 已被占据，放在3；                2次

CI：3%11=3 已被占据，放在4；4已被占据放在5   3次

I：9%11=9 已被占据，放在10                    2次

K：11%11=0                                    1次

X：24%11=2 已被占据放在3 已被占据放在4 已被占据放在5 已被占据放在6   5次

TA：20%11=9 已被占据放在10 已被占据放在0 已被占据放在1               4次

所以平均查找长度为（1+1+1+2+3+2+1+5+4）/9 = 20/9

 
总结：
开放寻址法：
优点：
不用指针，潜在地节约了空间，用这些空间可存放更多的槽，从而潜在地减少了冲突，提升了速度。
缺点：
采用开放定址法处理散列表的冲突时，其平均查找长度高于链接法处理冲突

拓展：
开放寻址法的一种改进的方式为二次探查（Quadratic Probing），即每次检查位置空间的步长为平方倍数。
也就是说，如果位置 s 被占用，则首先检查 s + 1^2 处，然后检查s - 1^2，s + 2^2，s - 2^2，s + 3^2 依此类推，
而不是象线性探查那样以 s + 1，s + 2 ... 方式增长。尽管如此，二次探查同样也会导致同类哈希聚集问题（Secondary Clustering）。
