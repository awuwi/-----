问题：
★1.为什么不用数组+数组来实现
答：
简单版回答：
首先回答数组与链表的区别：
数组索引查询效率高，但是插入效率低；数组需要定义长度，可能造成资源浪费；
链表插入效率高，查询效率低。
具体版回答：
如果用数组+数组实现，那么当有hash冲突时，在数组上插入元素需要对整个数组移动，效率太低；
    用链表来解决冲突，使用头插法效率高，但是也带来了问题，就是查找效率低，怎么办呢？
    ★在Java1.8版本，在链表长度达到8的时候，用红黑树代替链表，查询效率就提升了。
    但是这样使用红黑树也有一个缺点，插入效率没有链表高，这也可能是HashMap底层为什么不用红黑树（或者AVL）组成的数组的原因之一。
                                                    

★2.为什么不一直用红黑树来维护hash冲突
答：在冲突的长度小于等于6时，维护一个树的代价远远高于链表。（长度减少到6时红黑树转换为链表）

★3.为什么用红黑树而不用AVL数（二叉平衡搜索树）
Trees in Java Collections are implemented using red-black trees
红黑树是牺牲了严格的高度平衡的优越条件为代价，★★它只要求部分地达到平衡要求，★★降低了对旋转的要求，从而提高了性能。
红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。
当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。
答：两者的查询、删除和插入时间复杂度都是O(logn)。
    但是，AVL树更加严格平衡，因此可以提供更快的查找效果；对于查找密集型任务，使用AVL树。
    对于插入密集型任务，请使用红黑树。
    
    插入和删除方面，AVL树速度较慢：需要更高的旋转次数才能在修改时正确地重新平衡数据结构。
  
  
★★★红黑树 相比于 BST ， 能确保树的最长路径 <= 2*树的最短路径 ，因此查找性能更优 （红黑树O(logn), BST最坏为O(n)）
★★★红黑树 想比于 AVL ， 最多需要三次自旋就能达到平衡， 插入和删除的效率都要高于AVL
