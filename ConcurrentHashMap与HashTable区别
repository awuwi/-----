技术点：

1、悲观锁与乐观锁： 
悲观锁是指如果一个线程占用了一个锁，而导致其他所有需要这个锁的线程进入等待，一直到该锁被释放，换句话说就是这个锁被独占，比如说典型的就是synchronized；
乐观锁是指操作并不加锁，而是抱着尝试的态度去执行某项操作，如果操作失败或者操作冲突，那么就进入重试，一直到执行成功为止。

2、原子性，指令有序性和线程可见性： 
这三个性质在多线程编程中是核心的问题。
★原子性和事务的原子性一样，对于一个操作或者多个操作，要么都执行，要么都不执行。
★指令有序性是指，在我们编写的代码中，上下两个互不关联的语句不会被指令重排序。指令重排序是指处理器为了性能优化，在无关联的代码的执行是可能会和代码顺序不一致。比如说int i = 1；int j = 2；那么这两条语句的执行顺序可能会先执行int j = 2；
★线程可见性是指一个线程修改了某个变量，其他线程能马上知道。

3、无锁算法（nonblocking algorithms）： 
使用底层原子化的机器指令， 保证并发情况下数据的完整性。典型的如CAS算法。

4、内存屏障： 
在《深入理解JVM》中解释是：它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；
即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；它会强制将对缓存的修改操作立即写入主存；
如果是写操作，它会导致其他CPU中对应的缓存行无效。★★在使用volatile修饰的变量会产生内存屏障（后面会详细解释）。


Java内存模型
https://blog.csdn.net/u012403290/article/details/67636469
（1）解释：我根据这张图来解释java内存模型，从图中可以看出每个线程都需要从主内存中读取操作，这个就是java内存模型的规定之一，
所有的变量存储在主内存中，每个线程都需要从主内存中获得变量的值。

然后从图中可以看到每个线程获得数据之后会放入自己的工作内存，这个就是java内存模型的规定之二，
保证每个线程操作的都是从主内存拷贝的副本，也就是说线程不能直接写主内存的变量，需要把主内存的变量值读取之后放入自己的工作内存中的变量副本中，
然后操作这个副本。

最后线程与线程之间无法直接访问对方工作内存中的变量。最后需要解释一下这个访问规则局限于对象实例字段，静态字段等，
局部变量不包括在内，因为局部变量不存在竞争问题。

（2）基本执行步骤： 
a、lock（锁定）：在某一个线程在读取主内存的时候需要把变量锁定。 
b、unlock（解锁）：某一个线程读取玩变量值之后会释放锁定，别的线程就可以进入操作 
c、read（读取）：从主内存中读取变量的值并放入工作内存中 
d、load（加载）：从read操作得到的值放入工作内存变量副本中 
e、use（使用）：把工作内存中的一个变量值传递给执行引擎 
f、assign（赋值）：它把一个从执行引擎接收到的值赋值给工作内存的变量 
g、store（存储）：把工作内存中的一个变量的值传送到主内存中 
h、write（写入）：把store操作从工作内存中一个变量的值传送到主内存的变量中。

volatile
使用volatile关键字
用一句话概括volatile,它能够使变量在值发生改变时能尽快地让其他线程知道.

①使得变量更新变得具有可见性，只要被volatile修饰的变量的赋值一旦变化就会通知到其他线程，如果其他线程的工作内存中存在这个同一个变量拷贝副本，那么其他线程会放弃这个副本中变量的值，重新去主内存中获取

②产生了内存屏障，防止指令进行了重排序

总结：volatile修饰的变量具有可见性与有序性。  不保证原子性（如a++操作）。
可见性可以保证保证  获得的当前值是内存中的最新值


volatile详解
首先我们要先意识到有这样的现象,编译器为了加快程序运行的速度,对一些变量的写操作会先在寄存器或者是CPU缓存上进行,最后才写入内存.
而在这个过程,变量的新值对其他线程是不可见的.而volatile的作用就是使它修饰的变量的读写操作都必须在内存中进行!

volatile与synchronized
volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,★需要从主存中读取,★synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.
volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.
★volatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证变量的修改可见性和原子性.
★volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.
volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化.

CAS算法
ConcurrentHashMap是如何实现线程安全的？？？
★实现了三种原子操作
★★★在jdk1.8中主要是采用了CAS算法实现线程安全的。
还有一点是jdk1.8优化的结果，在以前的ConcurrentHashMap中是锁定了Segment，而在jdk1.8被移除，现在锁定的是一个Node头节点
（注意，synchronized锁定的是头结点，这一点从下面的源码中就可以看出来），减小了锁的粒度，性能和冲突都会减少


锁优化
以上介绍的锁不是我们代码中能够控制的，但是借鉴上面的思想，我们可以优化我们自己线程的加锁操作；

减少锁的时间
不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；
减少锁的粒度
它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；

java中很多数据结构都是采用这种方法提高并发操作的效率：
ConcurrentHashMap的锁分段技术
LinkedBlockingQueue也体现了这样的思想，在队列头入队，在队列尾出队，入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高；

使用读写锁
ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写；

读写分离
CopyOnWriteArrayList 、CopyOnWriteArraySet 
我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素,而是操作容器的副本。
所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。

使用cas
如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用cas效率会更高，因为加锁会导致线程的上下文切换，
如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+cas操作会是非常高效的选择；

ConcurrentHashMap在1.7与1.8中的区别
在1.7中，用分段锁技术，对容器中数据加多把锁，减低锁竞争，效率比单个HashTable快N倍。
1.8中，采用CAS+volite技术，volite能够保证有序和可见性，CAS保证原子性，达到线程安全的效果，且执行效率很高。


